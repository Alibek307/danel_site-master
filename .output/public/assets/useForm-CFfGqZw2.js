import{j as k,c as se,r as T,P as le,m as F,n as ue,D as G,p as re}from"./main-DRxoYVQ_.js";function Ae({className:s,type:a,...e}){return k.jsx("input",{type:a,"data-slot":"input",className:se("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm","focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]","aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive","[&:-webkit-autofill]:shadow-[0_0_0_1000px_var(--background)_inset]","[&:-webkit-autofill]:[-webkit-text-fill-color:var(--foreground)]","[&:-webkit-autofill:hover]:shadow-[0_0_0_1000px_var(--background)_inset]","[&:-webkit-autofill:focus]:shadow-[0_0_0_1000px_var(--background)_inset]","dark:[&:-webkit-autofill]:shadow-[0_0_0_1000px_var(--background)_inset]",s),...e})}var ce="Label",ae=T.forwardRef((s,a)=>k.jsx(le.label,{...s,ref:a,onMouseDown:e=>{e.target.closest("button, input, select, textarea")||(s.onMouseDown?.(e),!e.defaultPrevented&&e.detail>1&&e.preventDefault())}}));ae.displayName=ce;var de=ae;function ke({className:s,...a}){return k.jsx(de,{"data-slot":"label",className:se("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",s),...a})}function N(s,a){return typeof s=="function"?s(a):s}function _(s,a){return Y(a).reduce((i,t)=>{if(i===null)return null;if(typeof i<"u")return i[t]},s)}function $(s,a,e){const i=Y(a);function t(r){if(!i.length)return N(e,r);const o=i.shift();if(typeof o=="string"||typeof o=="number"&&!Array.isArray(r))return typeof r=="object"?(r===null&&(r={}),{...r,[o]:t(r[o])}):{[o]:t()};if(Array.isArray(r)&&typeof o=="number"){const l=r.slice(0,o);return[...l.length?l:new Array(o),t(r[o]),...r.slice(o+1)]}return[...new Array(o),t()]}return t(s)}function he(s,a){const e=Y(a);function i(t){if(!t)return;if(e.length===1){const o=e[0];if(Array.isArray(t)&&typeof o=="number")return t.filter((m,h)=>h!==o);const{[o]:l,...d}=t;return d}const r=e.shift();if(typeof r=="string"&&typeof t=="object")return{...t,[r]:i(t[r])};if(typeof r=="number"&&Array.isArray(t)){if(r>=t.length)return t;const o=t.slice(0,r);return[...o.length?o:new Array(r),i(t[r]),...t.slice(r+1)]}throw new Error("It seems we have created an infinite loop in deleteBy. ")}return i(s)}const fe=/^(\d+)$/gm,me=/\.(\d+)(?=\.)/gm,ve=/^(\d+)\./gm,Me=/\.(\d+$)/gm,ge=/\.{2,}/gm,q="__int__",j=`${q}$1`;function Y(s){if(Array.isArray(s))return[...s];if(typeof s!="string")throw new Error("Path must be a string.");return s.replace(/(^\[)|]/gm,"").replace(/\[/g,".").replace(fe,j).replace(me,`.${j}.`).replace(ve,`${j}.`).replace(Me,`.${j}`).replace(ge,".").split(".").map(a=>{if(a.startsWith(q)){const e=a.substring(q.length),i=parseInt(e,10);return String(i)===e?i:e}return a})}function pe(s){return!(Array.isArray(s)&&s.length===0)}function J(s,a){const e=i=>i.validators.filter(Boolean).map(t=>({cause:t.cause,validate:t.fn}));return a.validationLogic({form:a.form,validators:a.validators,event:{type:s,async:!1},runValidation:e})}function Q(s,a){const{asyncDebounceMs:e}=a,{onBlurAsyncDebounceMs:i,onChangeAsyncDebounceMs:t,onDynamicAsyncDebounceMs:r}=a.validators||{},o=e??0,l=d=>d.validators.filter(Boolean).map(m=>{const h=m?.cause||s;let u=o;switch(h){case"change":u=t??o;break;case"blur":u=i??o;break;case"dynamic":u=r??o;break;case"submit":u=0;break}return s==="submit"&&(u=0),{cause:h,validate:m.fn,debounceMs:u}});return a.validationLogic({form:a.form,validators:a.validators,event:{type:s,async:!0},runValidation:l})}const X=s=>!!s&&typeof s=="object"&&"fields"in s;function D(s,a){if(Object.is(s,a))return!0;if(typeof s!="object"||s===null||typeof a!="object"||a===null)return!1;if(s instanceof Map&&a instanceof Map){if(s.size!==a.size)return!1;for(const[t,r]of s)if(!a.has(t)||!Object.is(r,a.get(t)))return!1;return!0}if(s instanceof Set&&a instanceof Set){if(s.size!==a.size)return!1;for(const t of s)if(!a.has(t))return!1;return!0}const e=Object.keys(s),i=Object.keys(a);if(e.length!==i.length)return!1;for(const t of e)if(!i.includes(t)||!D(s[t],a[t]))return!1;return!0}const Z=({newFormValidatorError:s,isPreviousErrorFromFormValidator:a,previousErrorValue:e})=>s?{newErrorValue:s,newSource:"form"}:a?{newErrorValue:void 0,newSource:void 0}:e?{newErrorValue:e,newSource:"field"}:{newErrorValue:void 0,newSource:void 0},ee=({formLevelError:s,fieldLevelError:a})=>a?{newErrorValue:a,newSource:"field"}:s?{newErrorValue:s,newSource:"form"}:{newErrorValue:void 0,newSource:void 0},L=s=>{if(!s.validators)return s.runValidation({validators:[],form:s.form});const a=s.event.async,e=a?void 0:{fn:s.validators.onMount,cause:"mount"},i={fn:a?s.validators.onChangeAsync:s.validators.onChange,cause:"change"},t={fn:a?s.validators.onBlurAsync:s.validators.onBlur,cause:"blur"},r={fn:a?s.validators.onSubmitAsync:s.validators.onSubmit,cause:"submit"},o=a?void 0:{fn:()=>{},cause:"server"};switch(s.event.type){case"mount":return s.runValidation({validators:[e],form:s.form});case"submit":return s.runValidation({validators:[i,t,r,o],form:s.form});case"server":return s.runValidation({validators:[],form:s.form});case"blur":return s.runValidation({validators:[t,o],form:s.form});case"change":return s.runValidation({validators:[i,o],form:s.form});default:throw new Error(`Unknown validation event type: ${s.event.type}`)}};function be(s){const a=new Map;for(const e of s){const i=[...e.path??[]].map(t=>{const r=typeof t=="object"?t.key:t;return typeof r=="number"?`[${r}]`:r}).join(".").replace(/\.\[/g,"[");a.set(i,(a.get(i)??[]).concat(e))}return Object.fromEntries(a)}const te=s=>{const a=be(s);return{form:a,fields:a}},O={validate({value:s,validationSource:a},e){const i=e["~standard"].validate(s);if(i instanceof Promise)throw new Error("async function passed to sync validator");if(i.issues)return a==="field"?i.issues:te(i.issues)},async validateAsync({value:s,validationSource:a},e){const i=await e["~standard"].validate(s);if(i.issues)return a==="field"?i.issues:te(i.issues)}},oe=s=>!!s&&"~standard"in s,U={isValidating:!1,isTouched:!1,isBlurred:!1,isDirty:!1,isPristine:!0,isValid:!0,isDefaultValue:!0,errors:[],errorMap:{},errorSourceMap:{}};function x(s){function a(u,n,c,M){const f=i(u,n,c,M);({insert:()=>l(f,u,n),remove:()=>d(f),swap:()=>M!==void 0&&h(f,u,n,M),move:()=>M!==void 0&&m(f,u,n,M)})[c]()}function e(u,n){return`${u}[${n}]`}function i(u,n,c,M){const f=[e(u,n)];if(c==="swap")f.push(e(u,M));else if(c==="move"){const[v,g]=[Math.min(n,M),Math.max(n,M)];for(let p=v;p<=g;p++)f.push(e(u,p))}else{const v=s.getFieldValue(u),g=Array.isArray(v)?v.length:0;for(let p=n+1;p<g;p++)f.push(e(u,p))}return Object.keys(s.fieldInfo).filter(v=>f.some(g=>v.startsWith(g)))}function t(u,n){return u.replace(/\[(\d+)\]/,(c,M)=>{const f=parseInt(M,10);return`[${n==="up"?f+1:Math.max(0,f-1)}]`})}function r(u,n){(n==="up"?u:[...u].reverse()).forEach(M=>{const f=t(M.toString(),n),v=s.getFieldMeta(f);v?s.setFieldMeta(M,v):s.setFieldMeta(M,o())})}const o=()=>U,l=(u,n,c)=>{r(u,"down"),u.forEach(M=>{M.toString().startsWith(e(n,c))&&s.setFieldMeta(M,o())})},d=u=>{r(u,"up")},m=(u,n,c,M)=>{const f=new Map(Object.keys(s.fieldInfo).filter(v=>v.startsWith(e(n,c))).map(v=>[v,s.getFieldMeta(v)]));r(u,c<M?"up":"down"),Object.keys(s.fieldInfo).filter(v=>v.startsWith(e(n,M))).forEach(v=>{const g=v.replace(e(n,M),e(n,c)),p=f.get(g);p&&s.setFieldMeta(v,p)})},h=(u,n,c,M)=>{u.forEach(f=>{if(!f.toString().startsWith(e(n,c)))return;const v=f.toString().replace(e(n,c),e(n,M)),[g,p]=[s.getFieldMeta(f),s.getFieldMeta(v)];g&&s.setFieldMeta(v,g),p&&s.setFieldMeta(f,p)})};return{handleArrayFieldMetaShift:a}}function H(s){return{values:s.values??{},errorMap:s.errorMap??{},fieldMetaBase:s.fieldMetaBase??{},isSubmitted:s.isSubmitted??!1,isSubmitting:s.isSubmitting??!1,isValidating:s.isValidating??!1,submissionAttempts:s.submissionAttempts??0,isSubmitSuccessful:s.isSubmitSuccessful??!1,validationMetaMap:s.validationMetaMap??{onChange:void 0,onBlur:void 0,onSubmit:void 0,onMount:void 0,onServer:void 0,onDynamic:void 0}}}class ye{constructor(a){this.options={},this.fieldInfo={},this.prevTransformArray=[],this.mount=()=>{const e=this.fieldMetaDerived.mount(),i=this.store.mount(),t=()=>{e(),i()};this.options.listeners?.onMount?.({formApi:this});const{onMount:r}=this.options.validators||{};return r&&this.validateSync("mount"),t},this.update=e=>{if(!e)return;const i=this.options;this.options=e;const t=!!e.transform?.deps?.some((l,d)=>l!==this.prevTransformArray[d]),r=e.defaultValues&&!D(e.defaultValues,i.defaultValues)&&!this.state.isTouched,o=!D(e.defaultState,i.defaultState)&&!this.state.isTouched;!r&&!o&&!t||F(()=>{this.baseStore.setState(()=>H(Object.assign({},this.state,o?e.defaultState:{},r?{values:e.defaultValues}:{},t?{_force_re_eval:!this.state._force_re_eval}:{})))})},this.reset=(e,i)=>{const{fieldMeta:t}=this.state,r=this.resetFieldMeta(t);e&&!i?.keepDefaultValues&&(this.options={...this.options,defaultValues:e}),this.baseStore.setState(()=>H({...this.options.defaultState,values:e??this.options.defaultValues??this.options.defaultState?.values,fieldMetaBase:r}))},this.validateAllFields=async e=>{const i=[];return F(()=>{Object.values(this.fieldInfo).forEach(r=>{if(!r.instance)return;const o=r.instance;i.push(Promise.resolve().then(()=>o.validate(e,{skipFormValidation:!0}))),r.instance.state.meta.isTouched||r.instance.setMeta(l=>({...l,isTouched:!0}))})}),(await Promise.all(i)).flat()},this.validateArrayFieldsStartingFrom=async(e,i,t)=>{const r=this.getFieldValue(e),o=Array.isArray(r)?Math.max(r.length-1,0):null,l=[`${e}[${i}]`];for(let u=i+1;u<=(o??0);u++)l.push(`${e}[${u}]`);const d=Object.keys(this.fieldInfo).filter(u=>l.some(n=>u.startsWith(n))),m=[];return F(()=>{d.forEach(u=>{m.push(Promise.resolve().then(()=>this.validateField(u,t)))})}),(await Promise.all(m)).flat()},this.validateField=(e,i)=>{const t=this.fieldInfo[e]?.instance;return t?(t.state.meta.isTouched||t.setMeta(r=>({...r,isTouched:!0})),t.validate(i)):[]},this.validateSync=e=>{const i=J(e,{...this.options,form:this,validationLogic:this.options.validationLogic||L});let t=!1;const r={};return F(()=>{for(const d of i){if(!d.validate)continue;const m=this.runValidator({validate:d.validate,value:{value:this.state.values,formApi:this,validationSource:"form"},type:"validate"}),{formError:h,fieldErrors:u}=K(m),n=P(d.cause);for(const c of Object.keys(this.state.fieldMeta)){const M=this.getFieldMeta(c);if(!M)continue;const{errorMap:f,errorSourceMap:v}=M,g=u?.[c],{newErrorValue:p,newSource:y}=Z({newFormValidatorError:g,isPreviousErrorFromFormValidator:v?.[n]==="form",previousErrorValue:f?.[n]});y==="form"&&(r[c]={...r[c],[n]:g}),f?.[n]!==p&&this.setFieldMeta(c,S=>({...S,errorMap:{...S.errorMap,[n]:p},errorSourceMap:{...S.errorSourceMap,[n]:y}}))}this.state.errorMap?.[n]!==h&&this.baseStore.setState(c=>({...c,errorMap:{...c.errorMap,[n]:h}})),(h||u)&&(t=!0)}const o=P("submit");this.state.errorMap?.[o]&&e!=="submit"&&!t&&this.baseStore.setState(d=>({...d,errorMap:{...d.errorMap,[o]:void 0}}));const l=P("server");this.state.errorMap?.[l]&&e!=="server"&&!t&&this.baseStore.setState(d=>({...d,errorMap:{...d.errorMap,[l]:void 0}}))}),{hasErrored:t,fieldsErrorMap:r}},this.validateAsync=async e=>{const i=Q(e,{...this.options,form:this,validationLogic:this.options.validationLogic||L});this.state.isFormValidating||this.baseStore.setState(d=>({...d,isFormValidating:!0}));const t=[];let r;for(const d of i){if(!d.validate)continue;const m=P(d.cause);this.state.validationMetaMap[m]?.lastAbortController.abort();const u=new AbortController;this.state.validationMetaMap[m]={lastAbortController:u},t.push(new Promise(async n=>{let c;try{c=await new Promise((g,p)=>{setTimeout(async()=>{if(u.signal.aborted)return g(void 0);try{g(await this.runValidator({validate:d.validate,value:{value:this.state.values,formApi:this,validationSource:"form",signal:u.signal},type:"validateAsync"}))}catch(y){p(y)}},d.debounceMs)})}catch(g){c=g}const{formError:M,fieldErrors:f}=K(c);f&&(r=r?{...r,...f}:f);const v=P(d.cause);for(const g of Object.keys(this.state.fieldMeta)){const p=this.getFieldMeta(g);if(!p)continue;const{errorMap:y,errorSourceMap:S}=p,E=r?.[g],{newErrorValue:w,newSource:B}=Z({newFormValidatorError:E,isPreviousErrorFromFormValidator:S?.[v]==="form",previousErrorValue:y?.[v]});y?.[v]!==w&&this.setFieldMeta(g,V=>({...V,errorMap:{...V.errorMap,[v]:w},errorSourceMap:{...V.errorSourceMap,[v]:B}}))}this.baseStore.setState(g=>({...g,errorMap:{...g.errorMap,[v]:M}})),n(r?{fieldErrors:r,errorMapKey:v}:void 0)}))}let o=[];const l={};if(t.length){o=await Promise.all(t);for(const d of o)if(d?.fieldErrors){const{errorMapKey:m}=d;for(const[h,u]of Object.entries(d.fieldErrors)){const c={...l[h]||{},[m]:u};l[h]=c}}}return this.baseStore.setState(d=>({...d,isFormValidating:!1})),l},this.validate=e=>{const{hasErrored:i,fieldsErrorMap:t}=this.validateSync(e);return i&&!this.options.asyncAlways?t:this.validateAsync(e)},this.getFieldValue=e=>_(this.state.values,e),this.getFieldMeta=e=>this.state.fieldMeta[e],this.getFieldInfo=e=>this.fieldInfo[e]||={instance:null,validationMetaMap:{onChange:void 0,onBlur:void 0,onSubmit:void 0,onMount:void 0,onServer:void 0,onDynamic:void 0}},this.setFieldMeta=(e,i)=>{this.baseStore.setState(t=>({...t,fieldMetaBase:{...t.fieldMetaBase,[e]:N(i,t.fieldMetaBase[e])}}))},this.resetFieldMeta=e=>Object.keys(e).reduce((i,t)=>{const r=t;return i[r]=U,i},{}),this.setFieldValue=(e,i,t)=>{const r=t?.dontUpdateMeta??!1;F(()=>{r||this.setFieldMeta(e,o=>({...o,isTouched:!0,isDirty:!0,errorMap:{...o?.errorMap,onMount:void 0}})),this.baseStore.setState(o=>({...o,values:$(o.values,e,i)}))})},this.deleteField=e=>{const t=[...Object.keys(this.fieldInfo).filter(r=>{const o=e.toString();return r!==o&&r.startsWith(o)}),e];this.baseStore.setState(r=>{const o={...r};return t.forEach(l=>{o.values=he(o.values,l),delete this.fieldInfo[l],delete o.fieldMetaBase[l]}),o})},this.pushFieldValue=(e,i,t)=>{this.setFieldValue(e,r=>[...Array.isArray(r)?r:[],i],t),this.validateField(e,"change")},this.insertFieldValue=async(e,i,t,r)=>{this.setFieldValue(e,o=>[...o.slice(0,i),t,...o.slice(i)],r),await this.validateField(e,"change"),x(this).handleArrayFieldMetaShift(e,i,"insert"),await this.validateArrayFieldsStartingFrom(e,i,"change")},this.replaceFieldValue=async(e,i,t,r)=>{this.setFieldValue(e,o=>o.map((l,d)=>d===i?t:l),r),await this.validateField(e,"change"),await this.validateArrayFieldsStartingFrom(e,i,"change")},this.removeFieldValue=async(e,i,t)=>{const r=this.getFieldValue(e),o=Array.isArray(r)?Math.max(r.length-1,0):null;if(this.setFieldValue(e,l=>l.filter((d,m)=>m!==i),t),x(this).handleArrayFieldMetaShift(e,i,"remove"),o!==null){const l=`${e}[${o}]`;this.deleteField(l)}await this.validateField(e,"change"),await this.validateArrayFieldsStartingFrom(e,i,"change")},this.swapFieldValues=(e,i,t,r)=>{this.setFieldValue(e,o=>{const l=o[i],d=o[t];return $($(o,`${i}`,d),`${t}`,l)},r),x(this).handleArrayFieldMetaShift(e,i,"swap",t),this.validateField(e,"change"),this.validateField(`${e}[${i}]`,"change"),this.validateField(`${e}[${t}]`,"change")},this.moveFieldValues=(e,i,t,r)=>{this.setFieldValue(e,o=>{const l=[...o];return l.splice(t,0,l.splice(i,1)[0]),l},r),x(this).handleArrayFieldMetaShift(e,i,"move",t),this.validateField(e,"change"),this.validateField(`${e}[${i}]`,"change"),this.validateField(`${e}[${t}]`,"change")},this.clearFieldValues=(e,i)=>{const t=this.getFieldValue(e),r=Array.isArray(t)?Math.max(t.length-1,0):null;if(this.setFieldValue(e,[],i),r!==null)for(let o=0;o<=r;o++){const l=`${e}[${o}]`;this.deleteField(l)}this.validateField(e,"change")},this.resetField=e=>{this.baseStore.setState(i=>({...i,fieldMetaBase:{...i.fieldMetaBase,[e]:U},values:this.options.defaultValues?$(i.values,e,_(this.options.defaultValues,e)):i.values}))},this.getAllErrors=()=>({form:{errors:this.state.errors,errorMap:this.state.errorMap},fields:Object.entries(this.state.fieldMeta).reduce((e,[i,t])=>(Object.keys(t).length&&t.errors.length&&(e[i]={errors:t.errors,errorMap:t.errorMap}),e),{})}),this.parseValuesWithSchema=e=>O.validate({value:this.state.values,validationSource:"form"},e),this.parseValuesWithSchemaAsync=e=>O.validateAsync({value:this.state.values,validationSource:"form"},e),this.baseStore=new ue(H({...a?.defaultState,values:a?.defaultValues??a?.defaultState?.values})),this.fieldMetaDerived=new G({deps:[this.baseStore],fn:({prevDepVals:e,currDepVals:i,prevVal:t})=>{const r=t,o=e?.[0],l=i[0];let d=0;const m={};for(const h of Object.keys(l.fieldMetaBase)){const u=l.fieldMetaBase[h],n=o?.fieldMetaBase[h],c=r?.[h],M=_(l.values,h);let f=c?.errors;if(!n||u.errorMap!==n.errorMap){f=Object.values(u.errorMap??{}).filter(S=>S!==void 0);const y=this.getFieldInfo(h)?.instance;y&&!y.options.disableErrorFlat&&(f=f?.flat(1))}const v=!pe(f??[]),g=!u.isDirty,p=D(M,_(this.options.defaultValues,h))||D(M,this.getFieldInfo(h)?.instance?.options.defaultValue);if(c&&c.isPristine===g&&c.isValid===v&&c.isDefaultValue===p&&c.errors===f&&u===n){m[h]=c,d++;continue}m[h]={...u,errors:f,isPristine:g,isValid:v,isDefaultValue:p}}return Object.keys(l.fieldMetaBase).length&&r&&d===Object.keys(l.fieldMetaBase).length?r:m}}),this.store=new G({deps:[this.baseStore,this.fieldMetaDerived],fn:({prevDepVals:e,currDepVals:i,prevVal:t})=>{const r=t,o=e?.[0],l=i[0],d=i[1],m=Object.values(d).filter(Boolean),h=m.some(b=>b.isValidating),u=m.every(b=>b.isValid),n=m.some(b=>b.isTouched),c=m.some(b=>b.isBlurred),M=m.every(b=>b.isDefaultValue),f=n&&l.errorMap?.onMount,v=m.some(b=>b.isDirty),g=!v,p=!!(l.errorMap?.onMount||m.some(b=>b?.errorMap?.onMount)),y=!!h;let S=r?.errors??[];(!o||l.errorMap!==o.errorMap)&&(S=Object.values(l.errorMap).reduce((b,A)=>A===void 0?b:A&&X(A)?(b.push(A.form),b):(b.push(A),b),[]));const E=S.length===0,w=u&&E,B=this.options.canSubmitWhenInvalid??!1,V=l.submissionAttempts===0&&!n&&!p||!y&&!l.isSubmitting&&w||B;let I=l.errorMap;if(f&&(S=S.filter(b=>b!==l.errorMap.onMount),I=Object.assign(I,{onMount:void 0})),r&&o&&r.errorMap===I&&r.fieldMeta===this.fieldMetaDerived.state&&r.errors===S&&r.isFieldsValidating===h&&r.isFieldsValid===u&&r.isFormValid===E&&r.isValid===w&&r.canSubmit===V&&r.isTouched===n&&r.isBlurred===c&&r.isPristine===g&&r.isDefaultValue===M&&r.isDirty===v&&D(o,l))return r;let C={...l,errorMap:I,fieldMeta:this.fieldMetaDerived.state,errors:S,isFieldsValidating:h,isFieldsValid:u,isFormValid:E,isValid:w,canSubmit:V,isTouched:n,isBlurred:c,isPristine:g,isDefaultValue:M,isDirty:v};const R=this.options.transform?.deps??[];if(R.length!==this.prevTransformArray.length||R.some((b,A)=>b!==this.prevTransformArray[A])){const b=Object.assign({},this,{state:C});this.options.transform?.fn(b),C=b.state,this.prevTransformArray=R}return C}}),this.handleSubmit=this.handleSubmit.bind(this),this.update(a||{})}get state(){return this.store.state}get formId(){return this.options.formId}runValidator(a){return oe(a.validate)?O[a.type](a.value,a.validate):a.validate(a.value)}async handleSubmit(a){if(this.baseStore.setState(t=>({...t,isSubmitted:!1,submissionAttempts:t.submissionAttempts+1,isSubmitSuccessful:!1})),F(()=>{Object.values(this.fieldInfo).forEach(t=>{t.instance&&(t.instance.state.meta.isTouched||t.instance.setMeta(r=>({...r,isTouched:!0})))})}),!this.state.canSubmit)return;const e=a??this.options.onSubmitMeta;this.baseStore.setState(t=>({...t,isSubmitting:!0}));const i=()=>{this.baseStore.setState(t=>({...t,isSubmitting:!1}))};if(await this.validateAllFields("submit"),!this.state.isFieldsValid){i(),this.options.onSubmitInvalid?.({value:this.state.values,formApi:this,meta:e});return}if(await this.validate("submit"),!this.state.isValid){i(),this.options.onSubmitInvalid?.({value:this.state.values,formApi:this,meta:e});return}F(()=>{Object.values(this.fieldInfo).forEach(t=>{t.instance?.options.listeners?.onSubmit?.({value:t.instance.state.value,fieldApi:t.instance})})}),this.options.listeners?.onSubmit?.({formApi:this,meta:e});try{await this.options.onSubmit?.({value:this.state.values,formApi:this,meta:e}),F(()=>{this.baseStore.setState(t=>({...t,isSubmitted:!0,isSubmitSuccessful:!0})),i()})}catch(t){throw this.baseStore.setState(r=>({...r,isSubmitSuccessful:!1})),i(),t}}setErrorMap(a){F(()=>{Object.entries(a).forEach(([e,i])=>{const t=e;if(X(i)){const{formError:r,fieldErrors:o}=K(i);for(const l of Object.keys(this.fieldInfo))this.getFieldMeta(l)&&this.setFieldMeta(l,m=>({...m,errorMap:{...m.errorMap,[t]:o?.[l]},errorSourceMap:{...m.errorSourceMap,[t]:"form"}}));this.baseStore.setState(l=>({...l,errorMap:{...l.errorMap,[t]:r}}))}else this.baseStore.setState(r=>({...r,errorMap:{...r.errorMap,[t]:i}}))})})}}function K(s){if(s){if(X(s)){const a=K(s.form).formError,e=s.fields;return{formError:a,fieldErrors:e}}return{formError:s}}return{formError:void 0}}function P(s){switch(s){case"submit":return"onSubmit";case"blur":return"onBlur";case"mount":return"onMount";case"server":return"onServer";case"dynamic":return"onDynamic";case"change":default:return"onChange"}}class Se{constructor(a){this.options={},this.mount=()=>{const e=this.store.mount();this.options.defaultValue!==void 0&&this.form.setFieldValue(this.name,this.options.defaultValue,{dontUpdateMeta:!0});const i=this.getInfo();i.instance=this,this.update(this.options);const{onMount:t}=this.options.validators||{};if(t){const r=this.runValidator({validate:t,value:{value:this.state.value,fieldApi:this,validationSource:"field"},type:"validate"});r&&this.setMeta(o=>({...o,errorMap:{...o?.errorMap,onMount:r},errorSourceMap:{...o?.errorSourceMap,onMount:"field"}}))}return this.options.listeners?.onMount?.({value:this.state.value,fieldApi:this}),e},this.update=e=>{this.options=e;const i=this.name!==e.name;if(this.name=e.name,this.state.value===void 0){const t=_(e.form.options.defaultValues,e.name),r=e.defaultValue??t;i?this.setValue(o=>o||r,{dontUpdateMeta:!0}):r!==void 0&&this.setValue(r,{dontUpdateMeta:!0})}this.form.getFieldMeta(this.name)===void 0&&this.setMeta(this.state.meta)},this.getValue=()=>this.form.getFieldValue(this.name),this.setValue=(e,i)=>{this.form.setFieldValue(this.name,e,i),this.triggerOnChangeListener(),this.validate("change")},this.getMeta=()=>this.store.state.meta,this.setMeta=e=>this.form.setFieldMeta(this.name,e),this.getInfo=()=>this.form.getFieldInfo(this.name),this.pushValue=(e,i)=>{this.form.pushFieldValue(this.name,e,i),this.triggerOnChangeListener()},this.insertValue=(e,i,t)=>{this.form.insertFieldValue(this.name,e,i,t),this.triggerOnChangeListener()},this.replaceValue=(e,i,t)=>{this.form.replaceFieldValue(this.name,e,i,t),this.triggerOnChangeListener()},this.removeValue=(e,i)=>{this.form.removeFieldValue(this.name,e,i),this.triggerOnChangeListener()},this.swapValues=(e,i,t)=>{this.form.swapFieldValues(this.name,e,i,t),this.triggerOnChangeListener()},this.moveValue=(e,i,t)=>{this.form.moveFieldValues(this.name,e,i,t),this.triggerOnChangeListener()},this.clearValues=e=>{this.form.clearFieldValues(this.name,e),this.triggerOnChangeListener()},this.getLinkedFields=e=>{const i=Object.values(this.form.fieldInfo),t=[];for(const r of i){if(!r.instance)continue;const{onChangeListenTo:o,onBlurListenTo:l}=r.instance.options.validators||{};e==="change"&&o?.includes(this.name)&&t.push(r.instance),e==="blur"&&l?.includes(this.name)&&t.push(r.instance)}return t},this.validateSync=(e,i)=>{const t=J(e,{...this.options,form:this.form,validationLogic:this.form.options.validationLogic||L}),o=this.getLinkedFields(e).reduce((m,h)=>{const u=J(e,{...h.options,form:h.form,validationLogic:h.form.options.validationLogic||L});return u.forEach(n=>{n.field=h}),m.concat(u)},[]);let l=!1;F(()=>{const m=(h,u)=>{const n=W(u.cause),c=u.validate?ie(h.runValidator({validate:u.validate,value:{value:h.store.state.value,validationSource:"field",fieldApi:h},type:"validate"})):void 0,M=i[n],{newErrorValue:f,newSource:v}=ee({formLevelError:M,fieldLevelError:c});h.state.meta.errorMap?.[n]!==f&&h.setMeta(g=>({...g,errorMap:{...g.errorMap,[n]:f},errorSourceMap:{...g.errorSourceMap,[n]:v}})),f&&(l=!0)};for(const h of t)m(this,h);for(const h of o)h.validate&&m(h.field,h)});const d=W("submit");return this.state.meta.errorMap?.[d]&&e!=="submit"&&!l&&this.setMeta(m=>({...m,errorMap:{...m.errorMap,[d]:void 0},errorSourceMap:{...m.errorSourceMap,[d]:void 0}})),{hasErrored:l}},this.validateAsync=async(e,i)=>{const t=Q(e,{...this.options,form:this.form,validationLogic:this.form.options.validationLogic||L}),r=await i,o=this.getLinkedFields(e),l=o.reduce((n,c)=>{const M=Q(e,{...c.options,form:c.form,validationLogic:c.form.options.validationLogic||L});return M.forEach(f=>{f.field=c}),n.concat(M)},[]);this.state.meta.isValidating||this.setMeta(n=>({...n,isValidating:!0}));for(const n of o)n.setMeta(c=>({...c,isValidating:!0}));const d=[],m=[],h=(n,c,M)=>{const f=W(c.cause);n.getInfo().validationMetaMap[f]?.lastAbortController.abort();const g=new AbortController;this.getInfo().validationMetaMap[f]={lastAbortController:g},M.push(new Promise(async p=>{let y;try{y=await new Promise((V,I)=>{this.timeoutIds.validations[c.cause]&&clearTimeout(this.timeoutIds.validations[c.cause]),this.timeoutIds.validations[c.cause]=setTimeout(async()=>{if(g.signal.aborted)return V(void 0);try{V(await this.runValidator({validate:c.validate,value:{value:n.store.state.value,fieldApi:n,signal:g.signal,validationSource:"field"},type:"validateAsync"}))}catch(C){I(C)}},c.debounceMs)})}catch(V){y=V}if(g.signal.aborted)return p(void 0);const S=ie(y),E=r[this.name]?.[f],{newErrorValue:w,newSource:B}=ee({formLevelError:E,fieldLevelError:S});n.setMeta(V=>({...V,errorMap:{...V?.errorMap,[f]:w},errorSourceMap:{...V.errorSourceMap,[f]:B}})),p(w)}))};for(const n of t)n.validate&&h(this,n,d);for(const n of l)n.validate&&h(n.field,n,m);let u=[];(d.length||m.length)&&(u=await Promise.all(d),await Promise.all(m)),this.setMeta(n=>({...n,isValidating:!1}));for(const n of o)n.setMeta(c=>({...c,isValidating:!1}));return u.filter(Boolean)},this.validate=(e,i)=>{if(!this.state.meta.isTouched)return[];const{fieldsErrorMap:t}=i?.skipFormValidation?{fieldsErrorMap:{}}:this.form.validateSync(e),{hasErrored:r}=this.validateSync(e,t[this.name]??{});if(r&&!this.options.asyncAlways)return this.getInfo().validationMetaMap[W(e)]?.lastAbortController.abort(),this.state.meta.errors;const o=i?.skipFormValidation?Promise.resolve({}):this.form.validateAsync(e);return this.validateAsync(e,o)},this.handleChange=e=>{this.setValue(e)},this.handleBlur=()=>{this.state.meta.isTouched||this.setMeta(i=>({...i,isTouched:!0})),this.state.meta.isBlurred||this.setMeta(i=>({...i,isBlurred:!0})),this.validate("blur"),this.triggerOnBlurListener()},this.parseValueWithSchema=e=>O.validate({value:this.state.value,validationSource:"field"},e),this.parseValueWithSchemaAsync=e=>O.validateAsync({value:this.state.value,validationSource:"field"},e),this.form=a.form,this.name=a.name,this.timeoutIds={validations:{},listeners:{},formListeners:{}},this.store=new G({deps:[this.form.store],fn:()=>{const e=this.form.getFieldValue(this.name),i=this.form.getFieldMeta(this.name)??{...U,...a.defaultMeta};return{value:e,meta:i}}}),this.options=a}get state(){return this.store.state}runValidator(a){return oe(a.validate)?O[a.type](a.value,a.validate):a.validate(a.value)}setErrorMap(a){this.setMeta(e=>({...e,errorMap:{...e.errorMap,...a}}))}triggerOnBlurListener(){const a=this.form.options.listeners?.onBlurDebounceMs;a&&a>0?(this.timeoutIds.formListeners.blur&&clearTimeout(this.timeoutIds.formListeners.blur),this.timeoutIds.formListeners.blur=setTimeout(()=>{this.form.options.listeners?.onBlur?.({formApi:this.form,fieldApi:this})},a)):this.form.options.listeners?.onBlur?.({formApi:this.form,fieldApi:this});const e=this.options.listeners?.onBlurDebounceMs;e&&e>0?(this.timeoutIds.listeners.blur&&clearTimeout(this.timeoutIds.listeners.blur),this.timeoutIds.listeners.blur=setTimeout(()=>{this.options.listeners?.onBlur?.({value:this.state.value,fieldApi:this})},e)):this.options.listeners?.onBlur?.({value:this.state.value,fieldApi:this})}triggerOnChangeListener(){const a=this.form.options.listeners?.onChangeDebounceMs;a&&a>0?(this.timeoutIds.formListeners.change&&clearTimeout(this.timeoutIds.formListeners.change),this.timeoutIds.formListeners.change=setTimeout(()=>{this.form.options.listeners?.onChange?.({formApi:this.form,fieldApi:this})},a)):this.form.options.listeners?.onChange?.({formApi:this.form,fieldApi:this});const e=this.options.listeners?.onChangeDebounceMs;e&&e>0?(this.timeoutIds.listeners.change&&clearTimeout(this.timeoutIds.listeners.change),this.timeoutIds.listeners.change=setTimeout(()=>{this.options.listeners?.onChange?.({value:this.state.value,fieldApi:this})},e)):this.options.listeners?.onChange?.({value:this.state.value,fieldApi:this})}}function ie(s){if(s)return s}function W(s){switch(s){case"submit":return"onSubmit";case"blur":return"onBlur";case"mount":return"onMount";case"server":return"onServer";case"dynamic":return"onDynamic";case"change":default:return"onChange"}}const z=typeof window<"u"?T.useLayoutEffect:T.useEffect;function Ve(s){const[a]=T.useState(()=>{const i=new Se({...s,form:s.form,name:s.name});return i.Field=ne,i});return z(a.mount,[a]),z(()=>{a.update(s)}),re(a.store,s.mode==="array"?e=>[e.meta,Object.keys(e.value??[]).length]:void 0),a}const ne=({children:s,...a})=>{const e=Ve(a),i=T.useMemo(()=>N(s,e),[s,e,e.state.value,e.state.meta]);return k.jsx(k.Fragment,{children:i})};function Fe({form:s,selector:a,children:e}){const i=re(s.store,a);return N(e,i)}function Ie(s){const[a]=T.useState(()=>{const e=new ye(s),i=e;return i.Field=function(r){return k.jsx(ne,{...r,form:e})},i.Subscribe=function(r){return k.jsx(Fe,{form:e,selector:r.selector,children:r.children})},i});return z(a.mount,[]),z(()=>{a.update(s)}),a}export{Ae as I,ke as L,Ie as u};
